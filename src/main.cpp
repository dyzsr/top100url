#include "../include/utils.h"
#include "../include/input.h"
#include "../include/output.h"
#include "../include/partition.h"
#include "../include/reduce.h"
#include "../include/merge.h"
#include "../include/config.h"

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cassert>
#include <string>
#include <vector>
#include <queue>
#include <omp.h>


struct CMP {
	bool operator() (const UrlCnt &a, const UrlCnt &b)
	{
		return a.cnt > b.cnt;
	}
};

std::vector<std::string> read_log(const char *filename)
{
	FILE *fpi = fopen(filename, "r");
	assert(fpi != NULL);

	std::vector<std::string> logs;

	char *log = new char[MAX_FNAME_SZ];
	while (~fscanf(fpi, "%s ", log)) {
		logs.emplace_back(log);
		fprintf(stderr, "read log: %s\n", log);
	}
	delete[] log;

	fclose(fpi);
	return logs;
}

void write_log(const char *filename, std::vector<std::string> &logs)
{
	FILE *fpo = fopen(filename, "w");
	for (size_t i = 0; i < logs.size(); i++) {
		fprintf(fpo, "%s\n", logs[i].c_str());
	}
	fclose(fpo);
}

std::vector<std::string> fn_partition(const char *input_filename)
{
	/** Partition **/
	fprintf(stderr, "Partitioning...\n");

	char *fname = new char[MAX_FNAME_SZ];

	Partition partition(FILE_SZ);
	Input in(input_filename, "r", BUF_SZ_L);

	// fpart: files generated by Partition
	std::vector<std::string> fpart;
	for (size_t i = 0;; i++) {
		sprintf(fname, "_tmp/part-%05zu", i);
		Output out(fname, "wb", 1 << 24);
		std::pair<size_t, bool> res = partition(in, out);
		if (res.first > 0) {
			fpart.emplace_back(fname);
			fprintf(stderr, "===> %s: %.1fM\n", fname, res.first / 1048576.);
		}
		if (res.second)
			break;
	}
	delete[] fname;

	fprintf(stderr, "Partition finished, %zu files generated.\n\n", fpart.size());
	return fpart;
}

std::vector<std::string> fn_reduce(std::vector<std::string> &fpart)
{
	/** Reduce **/
	fprintf(stderr, "Reducing...\n");

	// freduce: files generated by Reduce
	std::vector<std::string> freduce;

	omp_set_num_threads(4);

#pragma omp parallel
	{
#pragma omp for
		for (size_t i = 0; i < fpart.size(); i++) {
			// add filename to freduce
			char *fname = new char[40];
			sprintf(fname, "_tmp/iter-00-%05zu", i);

			Reduce reduce;
			Input in(fpart[i].c_str(), "rb", BUF_SZ_S);
			Output out(fname, "wb", BUF_SZ_S);
			std::pair<size_t, size_t> res = reduce(&in, &out);

#pragma omp critical
			{
				freduce.emplace_back(fname);
				fprintf(stderr, "===> %s: %zu -> %zu\n", fname, res.first, res.second);
			}
			delete[] fname;
		}
	}

	fprintf(stderr, "Reduce finished, %zu files generated.\n\n", freduce.size());

	return freduce;
}

std::string fn_merge(std::vector<std::string> fmerge)
{
	omp_set_num_threads(8);

	/** Merge **/
	fprintf(stderr, "Merging...\n");


	// fnew: files of next iteration
	std::vector<std::string> fnew;
	size_t iter_num = 0;

	while (fmerge.size() > 1) {
		size_t sz = fmerge.size();
		++iter_num;

		fprintf(stderr, "Iteration %zu...\n", iter_num);
		
#pragma omp parallel
		{
#pragma omp for
			for (size_t i = 0; i < sz; i += MERGE_NUM) {
				char *fname = new char[MAX_FNAME_SZ];
				size_t k = i / MERGE_NUM;
				sprintf(fname, "_tmp/iter-%02zu-%05zu", iter_num, k);

				Output out(fname, "wb", BUF_SZ_L);
				Merge merge;


				std::vector<Input *> ins;
				for (size_t j = 0; i + j < sz && j < MERGE_NUM; j++) {
					ins.push_back(new Input(fmerge[i + j].c_str(), "rb", BUF_SZ_S));
				}

				auto res = merge(ins, out);

				for (size_t j = 0; i + j < sz && j < MERGE_NUM; j++) {
					delete ins[j];
				}

#pragma omp critical
				{
					fprintf(stderr, "===> %s\n", fname);
					fnew.emplace_back(fname);
					for (size_t j = 0; i + j < sz && j < MERGE_NUM; j++) {
						fprintf(stderr, "   <=== %s\n", fmerge[i + j].c_str());
					}
					fprintf(stderr, "total input = %zu, total output = %zu\n\n", res.first, res.second);
				}
				delete[] fname;
			}
		}

		fmerge = fnew;
		fnew.clear();

		fprintf(stderr, "%zu files generated.\n\n", fmerge.size());
	}

	return fmerge[0];
}

void fn_get_result(const char *result, const char *output)
{
	/** Collect the result **/
	fprintf(stderr, "Getting result...\n");

	Input in(result, "rb", BUF_SZ_L);

	std::priority_queue<UrlCnt, std::vector<UrlCnt>, CMP> pq;
	char *str = new char[MAX_URL_SZ + 1];
	for (;;) {
		UrlCnt urlcnt;
		in.getdb(&urlcnt.hash);
		in.getdb(&urlcnt.cnt);
		size_t n = in.getsb(str, MAX_URL_SZ);
		if (n == 0)
			break;
		urlcnt.url = std::string(str);

		pq.push(urlcnt);
		if (pq.size() > 100)
			pq.pop();
	}
	delete[] str;

	std::vector<UrlCnt> rankings;
	while (pq.size()) {
		UrlCnt urlcnt = pq.top(); pq.pop();
		rankings.push_back(urlcnt);
	}

	Output out(output, "w", BUF_SZ_L);
	while (rankings.size()) {
		UrlCnt urlcnt = rankings.back();
		rankings.pop_back();
		out.puts(urlcnt.url.c_str());
		out.putd(urlcnt.cnt);
	}

	fprintf(stderr, "===> %s\n\n", output);
}


int main(int argc, char *argv[])
{

	char *fname_part = nullptr;
	char *fname_res = nullptr;

	if (argc == 3) {
		fname_part = argv[1];
		fname_res = argv[2];
	}
	else {
		exit(1);
	}

	char cmd[100];

	sprintf(cmd, "mkdir -p _tmp");
	fprintf(stderr, "%s\n\n", cmd);
	system(cmd);

	/** Partition **/
	std::vector<std::string> fpart = fn_partition(fname_part);

	/** Reduce **/
	std::vector<std::string> freduce = fn_reduce(fpart);

	/** Delete the directory for partition **/
	sprintf(cmd, "rm _tmp/part-*");
	fprintf(stderr, "%s\n\n", cmd);
	system(cmd);

	/** Merge **/
	std::string result_filename = fn_merge(freduce);

	/** Get result **/
	fn_get_result(result_filename.c_str(), fname_res);


	/** Delete tmp directory **/

	sprintf(cmd, "rm -rd _tmp");
	fprintf(stderr, "%s\n", cmd);
	system(cmd);

	return 0;
}
